// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/octovy/pkg/domain/interfaces"
	"github.com/m-mizutani/octovy/pkg/domain/model"
	"github.com/m-mizutani/octovy/pkg/domain/types"
	"sync"
)

// Ensure, that ScanRepositoryMock does implement interfaces.ScanRepository.
// If this is not the case, regenerate this file with moq.
var _ interfaces.ScanRepository = &ScanRepositoryMock{}

// ScanRepositoryMock is a mock implementation of interfaces.ScanRepository.
//
//	func TestSomethingThatUsesScanRepository(t *testing.T) {
//
//		// make and configure a mocked interfaces.ScanRepository
//		mockedScanRepository := &ScanRepositoryMock{
//			BatchCreateVulnerabilitiesFunc: func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID, vulns []*model.Vulnerability) error {
//				panic("mock out the BatchCreateVulnerabilities method")
//			},
//			BatchUpdateVulnerabilityStatusFunc: func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID, updates map[string]types.VulnStatus) error {
//				panic("mock out the BatchUpdateVulnerabilityStatus method")
//			},
//			CreateOrUpdateBranchFunc: func(ctx context.Context, repoID types.GitHubRepoID, branch *model.Branch) error {
//				panic("mock out the CreateOrUpdateBranch method")
//			},
//			CreateOrUpdateRepositoryFunc: func(ctx context.Context, repo *model.Repository) error {
//				panic("mock out the CreateOrUpdateRepository method")
//			},
//			CreateOrUpdateTargetFunc: func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, target *model.Target) error {
//				panic("mock out the CreateOrUpdateTarget method")
//			},
//			GetBranchFunc: func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName) (*model.Branch, error) {
//				panic("mock out the GetBranch method")
//			},
//			GetRepositoryFunc: func(ctx context.Context, repoID types.GitHubRepoID) (*model.Repository, error) {
//				panic("mock out the GetRepository method")
//			},
//			GetTargetFunc: func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID) (*model.Target, error) {
//				panic("mock out the GetTarget method")
//			},
//			ListBranchesFunc: func(ctx context.Context, repoID types.GitHubRepoID) ([]*model.Branch, error) {
//				panic("mock out the ListBranches method")
//			},
//			ListRepositoriesFunc: func(ctx context.Context, installationID int64) ([]*model.Repository, error) {
//				panic("mock out the ListRepositories method")
//			},
//			ListTargetsFunc: func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName) ([]*model.Target, error) {
//				panic("mock out the ListTargets method")
//			},
//			ListVulnerabilitiesFunc: func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID) ([]*model.Vulnerability, error) {
//				panic("mock out the ListVulnerabilities method")
//			},
//		}
//
//		// use mockedScanRepository in code that requires interfaces.ScanRepository
//		// and then make assertions.
//
//	}
type ScanRepositoryMock struct {
	// BatchCreateVulnerabilitiesFunc mocks the BatchCreateVulnerabilities method.
	BatchCreateVulnerabilitiesFunc func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID, vulns []*model.Vulnerability) error

	// BatchUpdateVulnerabilityStatusFunc mocks the BatchUpdateVulnerabilityStatus method.
	BatchUpdateVulnerabilityStatusFunc func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID, updates map[string]types.VulnStatus) error

	// CreateOrUpdateBranchFunc mocks the CreateOrUpdateBranch method.
	CreateOrUpdateBranchFunc func(ctx context.Context, repoID types.GitHubRepoID, branch *model.Branch) error

	// CreateOrUpdateRepositoryFunc mocks the CreateOrUpdateRepository method.
	CreateOrUpdateRepositoryFunc func(ctx context.Context, repo *model.Repository) error

	// CreateOrUpdateTargetFunc mocks the CreateOrUpdateTarget method.
	CreateOrUpdateTargetFunc func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, target *model.Target) error

	// GetBranchFunc mocks the GetBranch method.
	GetBranchFunc func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName) (*model.Branch, error)

	// GetRepositoryFunc mocks the GetRepository method.
	GetRepositoryFunc func(ctx context.Context, repoID types.GitHubRepoID) (*model.Repository, error)

	// GetTargetFunc mocks the GetTarget method.
	GetTargetFunc func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID) (*model.Target, error)

	// ListBranchesFunc mocks the ListBranches method.
	ListBranchesFunc func(ctx context.Context, repoID types.GitHubRepoID) ([]*model.Branch, error)

	// ListRepositoriesFunc mocks the ListRepositories method.
	ListRepositoriesFunc func(ctx context.Context, installationID int64) ([]*model.Repository, error)

	// ListTargetsFunc mocks the ListTargets method.
	ListTargetsFunc func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName) ([]*model.Target, error)

	// ListVulnerabilitiesFunc mocks the ListVulnerabilities method.
	ListVulnerabilitiesFunc func(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID) ([]*model.Vulnerability, error)

	// calls tracks calls to the methods.
	calls struct {
		// BatchCreateVulnerabilities holds details about calls to the BatchCreateVulnerabilities method.
		BatchCreateVulnerabilities []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// BranchName is the branchName argument value.
			BranchName types.BranchName
			// TargetID is the targetID argument value.
			TargetID types.TargetID
			// Vulns is the vulns argument value.
			Vulns []*model.Vulnerability
		}
		// BatchUpdateVulnerabilityStatus holds details about calls to the BatchUpdateVulnerabilityStatus method.
		BatchUpdateVulnerabilityStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// BranchName is the branchName argument value.
			BranchName types.BranchName
			// TargetID is the targetID argument value.
			TargetID types.TargetID
			// Updates is the updates argument value.
			Updates map[string]types.VulnStatus
		}
		// CreateOrUpdateBranch holds details about calls to the CreateOrUpdateBranch method.
		CreateOrUpdateBranch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// Branch is the branch argument value.
			Branch *model.Branch
		}
		// CreateOrUpdateRepository holds details about calls to the CreateOrUpdateRepository method.
		CreateOrUpdateRepository []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo *model.Repository
		}
		// CreateOrUpdateTarget holds details about calls to the CreateOrUpdateTarget method.
		CreateOrUpdateTarget []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// BranchName is the branchName argument value.
			BranchName types.BranchName
			// Target is the target argument value.
			Target *model.Target
		}
		// GetBranch holds details about calls to the GetBranch method.
		GetBranch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// BranchName is the branchName argument value.
			BranchName types.BranchName
		}
		// GetRepository holds details about calls to the GetRepository method.
		GetRepository []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
		}
		// GetTarget holds details about calls to the GetTarget method.
		GetTarget []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// BranchName is the branchName argument value.
			BranchName types.BranchName
			// TargetID is the targetID argument value.
			TargetID types.TargetID
		}
		// ListBranches holds details about calls to the ListBranches method.
		ListBranches []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
		}
		// ListRepositories holds details about calls to the ListRepositories method.
		ListRepositories []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstallationID is the installationID argument value.
			InstallationID int64
		}
		// ListTargets holds details about calls to the ListTargets method.
		ListTargets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// BranchName is the branchName argument value.
			BranchName types.BranchName
		}
		// ListVulnerabilities holds details about calls to the ListVulnerabilities method.
		ListVulnerabilities []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID types.GitHubRepoID
			// BranchName is the branchName argument value.
			BranchName types.BranchName
			// TargetID is the targetID argument value.
			TargetID types.TargetID
		}
	}
	lockBatchCreateVulnerabilities     sync.RWMutex
	lockBatchUpdateVulnerabilityStatus sync.RWMutex
	lockCreateOrUpdateBranch           sync.RWMutex
	lockCreateOrUpdateRepository       sync.RWMutex
	lockCreateOrUpdateTarget           sync.RWMutex
	lockGetBranch                      sync.RWMutex
	lockGetRepository                  sync.RWMutex
	lockGetTarget                      sync.RWMutex
	lockListBranches                   sync.RWMutex
	lockListRepositories               sync.RWMutex
	lockListTargets                    sync.RWMutex
	lockListVulnerabilities            sync.RWMutex
}

// BatchCreateVulnerabilities calls BatchCreateVulnerabilitiesFunc.
func (mock *ScanRepositoryMock) BatchCreateVulnerabilities(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID, vulns []*model.Vulnerability) error {
	if mock.BatchCreateVulnerabilitiesFunc == nil {
		panic("ScanRepositoryMock.BatchCreateVulnerabilitiesFunc: method is nil but ScanRepository.BatchCreateVulnerabilities was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
		Vulns      []*model.Vulnerability
	}{
		Ctx:        ctx,
		RepoID:     repoID,
		BranchName: branchName,
		TargetID:   targetID,
		Vulns:      vulns,
	}
	mock.lockBatchCreateVulnerabilities.Lock()
	mock.calls.BatchCreateVulnerabilities = append(mock.calls.BatchCreateVulnerabilities, callInfo)
	mock.lockBatchCreateVulnerabilities.Unlock()
	return mock.BatchCreateVulnerabilitiesFunc(ctx, repoID, branchName, targetID, vulns)
}

// BatchCreateVulnerabilitiesCalls gets all the calls that were made to BatchCreateVulnerabilities.
// Check the length with:
//
//	len(mockedScanRepository.BatchCreateVulnerabilitiesCalls())
func (mock *ScanRepositoryMock) BatchCreateVulnerabilitiesCalls() []struct {
	Ctx        context.Context
	RepoID     types.GitHubRepoID
	BranchName types.BranchName
	TargetID   types.TargetID
	Vulns      []*model.Vulnerability
} {
	var calls []struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
		Vulns      []*model.Vulnerability
	}
	mock.lockBatchCreateVulnerabilities.RLock()
	calls = mock.calls.BatchCreateVulnerabilities
	mock.lockBatchCreateVulnerabilities.RUnlock()
	return calls
}

// BatchUpdateVulnerabilityStatus calls BatchUpdateVulnerabilityStatusFunc.
func (mock *ScanRepositoryMock) BatchUpdateVulnerabilityStatus(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID, updates map[string]types.VulnStatus) error {
	if mock.BatchUpdateVulnerabilityStatusFunc == nil {
		panic("ScanRepositoryMock.BatchUpdateVulnerabilityStatusFunc: method is nil but ScanRepository.BatchUpdateVulnerabilityStatus was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
		Updates    map[string]types.VulnStatus
	}{
		Ctx:        ctx,
		RepoID:     repoID,
		BranchName: branchName,
		TargetID:   targetID,
		Updates:    updates,
	}
	mock.lockBatchUpdateVulnerabilityStatus.Lock()
	mock.calls.BatchUpdateVulnerabilityStatus = append(mock.calls.BatchUpdateVulnerabilityStatus, callInfo)
	mock.lockBatchUpdateVulnerabilityStatus.Unlock()
	return mock.BatchUpdateVulnerabilityStatusFunc(ctx, repoID, branchName, targetID, updates)
}

// BatchUpdateVulnerabilityStatusCalls gets all the calls that were made to BatchUpdateVulnerabilityStatus.
// Check the length with:
//
//	len(mockedScanRepository.BatchUpdateVulnerabilityStatusCalls())
func (mock *ScanRepositoryMock) BatchUpdateVulnerabilityStatusCalls() []struct {
	Ctx        context.Context
	RepoID     types.GitHubRepoID
	BranchName types.BranchName
	TargetID   types.TargetID
	Updates    map[string]types.VulnStatus
} {
	var calls []struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
		Updates    map[string]types.VulnStatus
	}
	mock.lockBatchUpdateVulnerabilityStatus.RLock()
	calls = mock.calls.BatchUpdateVulnerabilityStatus
	mock.lockBatchUpdateVulnerabilityStatus.RUnlock()
	return calls
}

// CreateOrUpdateBranch calls CreateOrUpdateBranchFunc.
func (mock *ScanRepositoryMock) CreateOrUpdateBranch(ctx context.Context, repoID types.GitHubRepoID, branch *model.Branch) error {
	if mock.CreateOrUpdateBranchFunc == nil {
		panic("ScanRepositoryMock.CreateOrUpdateBranchFunc: method is nil but ScanRepository.CreateOrUpdateBranch was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		RepoID types.GitHubRepoID
		Branch *model.Branch
	}{
		Ctx:    ctx,
		RepoID: repoID,
		Branch: branch,
	}
	mock.lockCreateOrUpdateBranch.Lock()
	mock.calls.CreateOrUpdateBranch = append(mock.calls.CreateOrUpdateBranch, callInfo)
	mock.lockCreateOrUpdateBranch.Unlock()
	return mock.CreateOrUpdateBranchFunc(ctx, repoID, branch)
}

// CreateOrUpdateBranchCalls gets all the calls that were made to CreateOrUpdateBranch.
// Check the length with:
//
//	len(mockedScanRepository.CreateOrUpdateBranchCalls())
func (mock *ScanRepositoryMock) CreateOrUpdateBranchCalls() []struct {
	Ctx    context.Context
	RepoID types.GitHubRepoID
	Branch *model.Branch
} {
	var calls []struct {
		Ctx    context.Context
		RepoID types.GitHubRepoID
		Branch *model.Branch
	}
	mock.lockCreateOrUpdateBranch.RLock()
	calls = mock.calls.CreateOrUpdateBranch
	mock.lockCreateOrUpdateBranch.RUnlock()
	return calls
}

// CreateOrUpdateRepository calls CreateOrUpdateRepositoryFunc.
func (mock *ScanRepositoryMock) CreateOrUpdateRepository(ctx context.Context, repo *model.Repository) error {
	if mock.CreateOrUpdateRepositoryFunc == nil {
		panic("ScanRepositoryMock.CreateOrUpdateRepositoryFunc: method is nil but ScanRepository.CreateOrUpdateRepository was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Repo *model.Repository
	}{
		Ctx:  ctx,
		Repo: repo,
	}
	mock.lockCreateOrUpdateRepository.Lock()
	mock.calls.CreateOrUpdateRepository = append(mock.calls.CreateOrUpdateRepository, callInfo)
	mock.lockCreateOrUpdateRepository.Unlock()
	return mock.CreateOrUpdateRepositoryFunc(ctx, repo)
}

// CreateOrUpdateRepositoryCalls gets all the calls that were made to CreateOrUpdateRepository.
// Check the length with:
//
//	len(mockedScanRepository.CreateOrUpdateRepositoryCalls())
func (mock *ScanRepositoryMock) CreateOrUpdateRepositoryCalls() []struct {
	Ctx  context.Context
	Repo *model.Repository
} {
	var calls []struct {
		Ctx  context.Context
		Repo *model.Repository
	}
	mock.lockCreateOrUpdateRepository.RLock()
	calls = mock.calls.CreateOrUpdateRepository
	mock.lockCreateOrUpdateRepository.RUnlock()
	return calls
}

// CreateOrUpdateTarget calls CreateOrUpdateTargetFunc.
func (mock *ScanRepositoryMock) CreateOrUpdateTarget(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, target *model.Target) error {
	if mock.CreateOrUpdateTargetFunc == nil {
		panic("ScanRepositoryMock.CreateOrUpdateTargetFunc: method is nil but ScanRepository.CreateOrUpdateTarget was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		Target     *model.Target
	}{
		Ctx:        ctx,
		RepoID:     repoID,
		BranchName: branchName,
		Target:     target,
	}
	mock.lockCreateOrUpdateTarget.Lock()
	mock.calls.CreateOrUpdateTarget = append(mock.calls.CreateOrUpdateTarget, callInfo)
	mock.lockCreateOrUpdateTarget.Unlock()
	return mock.CreateOrUpdateTargetFunc(ctx, repoID, branchName, target)
}

// CreateOrUpdateTargetCalls gets all the calls that were made to CreateOrUpdateTarget.
// Check the length with:
//
//	len(mockedScanRepository.CreateOrUpdateTargetCalls())
func (mock *ScanRepositoryMock) CreateOrUpdateTargetCalls() []struct {
	Ctx        context.Context
	RepoID     types.GitHubRepoID
	BranchName types.BranchName
	Target     *model.Target
} {
	var calls []struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		Target     *model.Target
	}
	mock.lockCreateOrUpdateTarget.RLock()
	calls = mock.calls.CreateOrUpdateTarget
	mock.lockCreateOrUpdateTarget.RUnlock()
	return calls
}

// GetBranch calls GetBranchFunc.
func (mock *ScanRepositoryMock) GetBranch(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName) (*model.Branch, error) {
	if mock.GetBranchFunc == nil {
		panic("ScanRepositoryMock.GetBranchFunc: method is nil but ScanRepository.GetBranch was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
	}{
		Ctx:        ctx,
		RepoID:     repoID,
		BranchName: branchName,
	}
	mock.lockGetBranch.Lock()
	mock.calls.GetBranch = append(mock.calls.GetBranch, callInfo)
	mock.lockGetBranch.Unlock()
	return mock.GetBranchFunc(ctx, repoID, branchName)
}

// GetBranchCalls gets all the calls that were made to GetBranch.
// Check the length with:
//
//	len(mockedScanRepository.GetBranchCalls())
func (mock *ScanRepositoryMock) GetBranchCalls() []struct {
	Ctx        context.Context
	RepoID     types.GitHubRepoID
	BranchName types.BranchName
} {
	var calls []struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
	}
	mock.lockGetBranch.RLock()
	calls = mock.calls.GetBranch
	mock.lockGetBranch.RUnlock()
	return calls
}

// GetRepository calls GetRepositoryFunc.
func (mock *ScanRepositoryMock) GetRepository(ctx context.Context, repoID types.GitHubRepoID) (*model.Repository, error) {
	if mock.GetRepositoryFunc == nil {
		panic("ScanRepositoryMock.GetRepositoryFunc: method is nil but ScanRepository.GetRepository was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		RepoID types.GitHubRepoID
	}{
		Ctx:    ctx,
		RepoID: repoID,
	}
	mock.lockGetRepository.Lock()
	mock.calls.GetRepository = append(mock.calls.GetRepository, callInfo)
	mock.lockGetRepository.Unlock()
	return mock.GetRepositoryFunc(ctx, repoID)
}

// GetRepositoryCalls gets all the calls that were made to GetRepository.
// Check the length with:
//
//	len(mockedScanRepository.GetRepositoryCalls())
func (mock *ScanRepositoryMock) GetRepositoryCalls() []struct {
	Ctx    context.Context
	RepoID types.GitHubRepoID
} {
	var calls []struct {
		Ctx    context.Context
		RepoID types.GitHubRepoID
	}
	mock.lockGetRepository.RLock()
	calls = mock.calls.GetRepository
	mock.lockGetRepository.RUnlock()
	return calls
}

// GetTarget calls GetTargetFunc.
func (mock *ScanRepositoryMock) GetTarget(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID) (*model.Target, error) {
	if mock.GetTargetFunc == nil {
		panic("ScanRepositoryMock.GetTargetFunc: method is nil but ScanRepository.GetTarget was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
	}{
		Ctx:        ctx,
		RepoID:     repoID,
		BranchName: branchName,
		TargetID:   targetID,
	}
	mock.lockGetTarget.Lock()
	mock.calls.GetTarget = append(mock.calls.GetTarget, callInfo)
	mock.lockGetTarget.Unlock()
	return mock.GetTargetFunc(ctx, repoID, branchName, targetID)
}

// GetTargetCalls gets all the calls that were made to GetTarget.
// Check the length with:
//
//	len(mockedScanRepository.GetTargetCalls())
func (mock *ScanRepositoryMock) GetTargetCalls() []struct {
	Ctx        context.Context
	RepoID     types.GitHubRepoID
	BranchName types.BranchName
	TargetID   types.TargetID
} {
	var calls []struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
	}
	mock.lockGetTarget.RLock()
	calls = mock.calls.GetTarget
	mock.lockGetTarget.RUnlock()
	return calls
}

// ListBranches calls ListBranchesFunc.
func (mock *ScanRepositoryMock) ListBranches(ctx context.Context, repoID types.GitHubRepoID) ([]*model.Branch, error) {
	if mock.ListBranchesFunc == nil {
		panic("ScanRepositoryMock.ListBranchesFunc: method is nil but ScanRepository.ListBranches was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		RepoID types.GitHubRepoID
	}{
		Ctx:    ctx,
		RepoID: repoID,
	}
	mock.lockListBranches.Lock()
	mock.calls.ListBranches = append(mock.calls.ListBranches, callInfo)
	mock.lockListBranches.Unlock()
	return mock.ListBranchesFunc(ctx, repoID)
}

// ListBranchesCalls gets all the calls that were made to ListBranches.
// Check the length with:
//
//	len(mockedScanRepository.ListBranchesCalls())
func (mock *ScanRepositoryMock) ListBranchesCalls() []struct {
	Ctx    context.Context
	RepoID types.GitHubRepoID
} {
	var calls []struct {
		Ctx    context.Context
		RepoID types.GitHubRepoID
	}
	mock.lockListBranches.RLock()
	calls = mock.calls.ListBranches
	mock.lockListBranches.RUnlock()
	return calls
}

// ListRepositories calls ListRepositoriesFunc.
func (mock *ScanRepositoryMock) ListRepositories(ctx context.Context, installationID int64) ([]*model.Repository, error) {
	if mock.ListRepositoriesFunc == nil {
		panic("ScanRepositoryMock.ListRepositoriesFunc: method is nil but ScanRepository.ListRepositories was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		InstallationID int64
	}{
		Ctx:            ctx,
		InstallationID: installationID,
	}
	mock.lockListRepositories.Lock()
	mock.calls.ListRepositories = append(mock.calls.ListRepositories, callInfo)
	mock.lockListRepositories.Unlock()
	return mock.ListRepositoriesFunc(ctx, installationID)
}

// ListRepositoriesCalls gets all the calls that were made to ListRepositories.
// Check the length with:
//
//	len(mockedScanRepository.ListRepositoriesCalls())
func (mock *ScanRepositoryMock) ListRepositoriesCalls() []struct {
	Ctx            context.Context
	InstallationID int64
} {
	var calls []struct {
		Ctx            context.Context
		InstallationID int64
	}
	mock.lockListRepositories.RLock()
	calls = mock.calls.ListRepositories
	mock.lockListRepositories.RUnlock()
	return calls
}

// ListTargets calls ListTargetsFunc.
func (mock *ScanRepositoryMock) ListTargets(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName) ([]*model.Target, error) {
	if mock.ListTargetsFunc == nil {
		panic("ScanRepositoryMock.ListTargetsFunc: method is nil but ScanRepository.ListTargets was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
	}{
		Ctx:        ctx,
		RepoID:     repoID,
		BranchName: branchName,
	}
	mock.lockListTargets.Lock()
	mock.calls.ListTargets = append(mock.calls.ListTargets, callInfo)
	mock.lockListTargets.Unlock()
	return mock.ListTargetsFunc(ctx, repoID, branchName)
}

// ListTargetsCalls gets all the calls that were made to ListTargets.
// Check the length with:
//
//	len(mockedScanRepository.ListTargetsCalls())
func (mock *ScanRepositoryMock) ListTargetsCalls() []struct {
	Ctx        context.Context
	RepoID     types.GitHubRepoID
	BranchName types.BranchName
} {
	var calls []struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
	}
	mock.lockListTargets.RLock()
	calls = mock.calls.ListTargets
	mock.lockListTargets.RUnlock()
	return calls
}

// ListVulnerabilities calls ListVulnerabilitiesFunc.
func (mock *ScanRepositoryMock) ListVulnerabilities(ctx context.Context, repoID types.GitHubRepoID, branchName types.BranchName, targetID types.TargetID) ([]*model.Vulnerability, error) {
	if mock.ListVulnerabilitiesFunc == nil {
		panic("ScanRepositoryMock.ListVulnerabilitiesFunc: method is nil but ScanRepository.ListVulnerabilities was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
	}{
		Ctx:        ctx,
		RepoID:     repoID,
		BranchName: branchName,
		TargetID:   targetID,
	}
	mock.lockListVulnerabilities.Lock()
	mock.calls.ListVulnerabilities = append(mock.calls.ListVulnerabilities, callInfo)
	mock.lockListVulnerabilities.Unlock()
	return mock.ListVulnerabilitiesFunc(ctx, repoID, branchName, targetID)
}

// ListVulnerabilitiesCalls gets all the calls that were made to ListVulnerabilities.
// Check the length with:
//
//	len(mockedScanRepository.ListVulnerabilitiesCalls())
func (mock *ScanRepositoryMock) ListVulnerabilitiesCalls() []struct {
	Ctx        context.Context
	RepoID     types.GitHubRepoID
	BranchName types.BranchName
	TargetID   types.TargetID
} {
	var calls []struct {
		Ctx        context.Context
		RepoID     types.GitHubRepoID
		BranchName types.BranchName
		TargetID   types.TargetID
	}
	mock.lockListVulnerabilities.RLock()
	calls = mock.calls.ListVulnerabilities
	mock.lockListVulnerabilities.RUnlock()
	return calls
}
