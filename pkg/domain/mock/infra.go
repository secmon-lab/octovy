// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"cloud.google.com/go/bigquery"
	"context"
	"github.com/m-mizutani/octovy/pkg/domain/interfaces"
	"github.com/m-mizutani/octovy/pkg/domain/model"
	"github.com/m-mizutani/octovy/pkg/domain/types"
	"net/http"
	"net/url"
	"sync"
)

// Ensure, that BigQueryMock does implement interfaces.BigQuery.
// If this is not the case, regenerate this file with moq.
var _ interfaces.BigQuery = &BigQueryMock{}

// BigQueryMock is a mock implementation of interfaces.BigQuery.
//
//	func TestSomethingThatUsesBigQuery(t *testing.T) {
//
//		// make and configure a mocked interfaces.BigQuery
//		mockedBigQuery := &BigQueryMock{
//			CreateTableFunc: func(ctx context.Context, md *bigquery.TableMetadata) error {
//				panic("mock out the CreateTable method")
//			},
//			GetMetadataFunc: func(ctx context.Context) (*bigquery.TableMetadata, error) {
//				panic("mock out the GetMetadata method")
//			},
//			InsertFunc: func(ctx context.Context, schema bigquery.Schema, data any, opts ...interfaces.BigQueryInsertOption) error {
//				panic("mock out the Insert method")
//			},
//			UpdateTableFunc: func(ctx context.Context, md bigquery.TableMetadataToUpdate, eTag string) error {
//				panic("mock out the UpdateTable method")
//			},
//		}
//
//		// use mockedBigQuery in code that requires interfaces.BigQuery
//		// and then make assertions.
//
//	}
type BigQueryMock struct {
	// CreateTableFunc mocks the CreateTable method.
	CreateTableFunc func(ctx context.Context, md *bigquery.TableMetadata) error

	// GetMetadataFunc mocks the GetMetadata method.
	GetMetadataFunc func(ctx context.Context) (*bigquery.TableMetadata, error)

	// InsertFunc mocks the Insert method.
	InsertFunc func(ctx context.Context, schema bigquery.Schema, data any, opts ...interfaces.BigQueryInsertOption) error

	// UpdateTableFunc mocks the UpdateTable method.
	UpdateTableFunc func(ctx context.Context, md bigquery.TableMetadataToUpdate, eTag string) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateTable holds details about calls to the CreateTable method.
		CreateTable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Md is the md argument value.
			Md *bigquery.TableMetadata
		}
		// GetMetadata holds details about calls to the GetMetadata method.
		GetMetadata []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Schema is the schema argument value.
			Schema bigquery.Schema
			// Data is the data argument value.
			Data any
			// Opts is the opts argument value.
			Opts []interfaces.BigQueryInsertOption
		}
		// UpdateTable holds details about calls to the UpdateTable method.
		UpdateTable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Md is the md argument value.
			Md bigquery.TableMetadataToUpdate
			// ETag is the eTag argument value.
			ETag string
		}
	}
	lockCreateTable sync.RWMutex
	lockGetMetadata sync.RWMutex
	lockInsert      sync.RWMutex
	lockUpdateTable sync.RWMutex
}

// CreateTable calls CreateTableFunc.
func (mock *BigQueryMock) CreateTable(ctx context.Context, md *bigquery.TableMetadata) error {
	if mock.CreateTableFunc == nil {
		panic("BigQueryMock.CreateTableFunc: method is nil but BigQuery.CreateTable was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Md  *bigquery.TableMetadata
	}{
		Ctx: ctx,
		Md:  md,
	}
	mock.lockCreateTable.Lock()
	mock.calls.CreateTable = append(mock.calls.CreateTable, callInfo)
	mock.lockCreateTable.Unlock()
	return mock.CreateTableFunc(ctx, md)
}

// CreateTableCalls gets all the calls that were made to CreateTable.
// Check the length with:
//
//	len(mockedBigQuery.CreateTableCalls())
func (mock *BigQueryMock) CreateTableCalls() []struct {
	Ctx context.Context
	Md  *bigquery.TableMetadata
} {
	var calls []struct {
		Ctx context.Context
		Md  *bigquery.TableMetadata
	}
	mock.lockCreateTable.RLock()
	calls = mock.calls.CreateTable
	mock.lockCreateTable.RUnlock()
	return calls
}

// GetMetadata calls GetMetadataFunc.
func (mock *BigQueryMock) GetMetadata(ctx context.Context) (*bigquery.TableMetadata, error) {
	if mock.GetMetadataFunc == nil {
		panic("BigQueryMock.GetMetadataFunc: method is nil but BigQuery.GetMetadata was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetMetadata.Lock()
	mock.calls.GetMetadata = append(mock.calls.GetMetadata, callInfo)
	mock.lockGetMetadata.Unlock()
	return mock.GetMetadataFunc(ctx)
}

// GetMetadataCalls gets all the calls that were made to GetMetadata.
// Check the length with:
//
//	len(mockedBigQuery.GetMetadataCalls())
func (mock *BigQueryMock) GetMetadataCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetMetadata.RLock()
	calls = mock.calls.GetMetadata
	mock.lockGetMetadata.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *BigQueryMock) Insert(ctx context.Context, schema bigquery.Schema, data any, opts ...interfaces.BigQueryInsertOption) error {
	if mock.InsertFunc == nil {
		panic("BigQueryMock.InsertFunc: method is nil but BigQuery.Insert was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Schema bigquery.Schema
		Data   any
		Opts   []interfaces.BigQueryInsertOption
	}{
		Ctx:    ctx,
		Schema: schema,
		Data:   data,
		Opts:   opts,
	}
	mock.lockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	mock.lockInsert.Unlock()
	return mock.InsertFunc(ctx, schema, data, opts...)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//
//	len(mockedBigQuery.InsertCalls())
func (mock *BigQueryMock) InsertCalls() []struct {
	Ctx    context.Context
	Schema bigquery.Schema
	Data   any
	Opts   []interfaces.BigQueryInsertOption
} {
	var calls []struct {
		Ctx    context.Context
		Schema bigquery.Schema
		Data   any
		Opts   []interfaces.BigQueryInsertOption
	}
	mock.lockInsert.RLock()
	calls = mock.calls.Insert
	mock.lockInsert.RUnlock()
	return calls
}

// UpdateTable calls UpdateTableFunc.
func (mock *BigQueryMock) UpdateTable(ctx context.Context, md bigquery.TableMetadataToUpdate, eTag string) error {
	if mock.UpdateTableFunc == nil {
		panic("BigQueryMock.UpdateTableFunc: method is nil but BigQuery.UpdateTable was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Md   bigquery.TableMetadataToUpdate
		ETag string
	}{
		Ctx:  ctx,
		Md:   md,
		ETag: eTag,
	}
	mock.lockUpdateTable.Lock()
	mock.calls.UpdateTable = append(mock.calls.UpdateTable, callInfo)
	mock.lockUpdateTable.Unlock()
	return mock.UpdateTableFunc(ctx, md, eTag)
}

// UpdateTableCalls gets all the calls that were made to UpdateTable.
// Check the length with:
//
//	len(mockedBigQuery.UpdateTableCalls())
func (mock *BigQueryMock) UpdateTableCalls() []struct {
	Ctx  context.Context
	Md   bigquery.TableMetadataToUpdate
	ETag string
} {
	var calls []struct {
		Ctx  context.Context
		Md   bigquery.TableMetadataToUpdate
		ETag string
	}
	mock.lockUpdateTable.RLock()
	calls = mock.calls.UpdateTable
	mock.lockUpdateTable.RUnlock()
	return calls
}

// Ensure, that GitHubAppMock does implement interfaces.GitHubApp.
// If this is not the case, regenerate this file with moq.
var _ interfaces.GitHubApp = &GitHubAppMock{}

// GitHubAppMock is a mock implementation of interfaces.GitHubApp.
//
//	func TestSomethingThatUsesGitHubApp(t *testing.T) {
//
//		// make and configure a mocked interfaces.GitHubApp
//		mockedGitHubApp := &GitHubAppMock{
//			GetArchiveURLFunc: func(ctx context.Context, input *interfaces.GetArchiveURLInput) (*url.URL, error) {
//				panic("mock out the GetArchiveURL method")
//			},
//			GetInstallationIDForOwnerFunc: func(ctx context.Context, owner string) (types.GitHubAppInstallID, error) {
//				panic("mock out the GetInstallationIDForOwner method")
//			},
//			HTTPClientFunc: func(installID types.GitHubAppInstallID) (*http.Client, error) {
//				panic("mock out the HTTPClient method")
//			},
//			ListInstallationReposFunc: func(ctx context.Context, installID types.GitHubAppInstallID) ([]*model.GitHubAPIRepository, error) {
//				panic("mock out the ListInstallationRepos method")
//			},
//		}
//
//		// use mockedGitHubApp in code that requires interfaces.GitHubApp
//		// and then make assertions.
//
//	}
type GitHubAppMock struct {
	// GetArchiveURLFunc mocks the GetArchiveURL method.
	GetArchiveURLFunc func(ctx context.Context, input *interfaces.GetArchiveURLInput) (*url.URL, error)

	// GetInstallationIDForOwnerFunc mocks the GetInstallationIDForOwner method.
	GetInstallationIDForOwnerFunc func(ctx context.Context, owner string) (types.GitHubAppInstallID, error)

	// HTTPClientFunc mocks the HTTPClient method.
	HTTPClientFunc func(installID types.GitHubAppInstallID) (*http.Client, error)

	// ListInstallationReposFunc mocks the ListInstallationRepos method.
	ListInstallationReposFunc func(ctx context.Context, installID types.GitHubAppInstallID) ([]*model.GitHubAPIRepository, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetArchiveURL holds details about calls to the GetArchiveURL method.
		GetArchiveURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input *interfaces.GetArchiveURLInput
		}
		// GetInstallationIDForOwner holds details about calls to the GetInstallationIDForOwner method.
		GetInstallationIDForOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner string
		}
		// HTTPClient holds details about calls to the HTTPClient method.
		HTTPClient []struct {
			// InstallID is the installID argument value.
			InstallID types.GitHubAppInstallID
		}
		// ListInstallationRepos holds details about calls to the ListInstallationRepos method.
		ListInstallationRepos []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstallID is the installID argument value.
			InstallID types.GitHubAppInstallID
		}
	}
	lockGetArchiveURL             sync.RWMutex
	lockGetInstallationIDForOwner sync.RWMutex
	lockHTTPClient                sync.RWMutex
	lockListInstallationRepos     sync.RWMutex
}

// GetArchiveURL calls GetArchiveURLFunc.
func (mock *GitHubAppMock) GetArchiveURL(ctx context.Context, input *interfaces.GetArchiveURLInput) (*url.URL, error) {
	if mock.GetArchiveURLFunc == nil {
		panic("GitHubAppMock.GetArchiveURLFunc: method is nil but GitHubApp.GetArchiveURL was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input *interfaces.GetArchiveURLInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGetArchiveURL.Lock()
	mock.calls.GetArchiveURL = append(mock.calls.GetArchiveURL, callInfo)
	mock.lockGetArchiveURL.Unlock()
	return mock.GetArchiveURLFunc(ctx, input)
}

// GetArchiveURLCalls gets all the calls that were made to GetArchiveURL.
// Check the length with:
//
//	len(mockedGitHubApp.GetArchiveURLCalls())
func (mock *GitHubAppMock) GetArchiveURLCalls() []struct {
	Ctx   context.Context
	Input *interfaces.GetArchiveURLInput
} {
	var calls []struct {
		Ctx   context.Context
		Input *interfaces.GetArchiveURLInput
	}
	mock.lockGetArchiveURL.RLock()
	calls = mock.calls.GetArchiveURL
	mock.lockGetArchiveURL.RUnlock()
	return calls
}

// GetInstallationIDForOwner calls GetInstallationIDForOwnerFunc.
func (mock *GitHubAppMock) GetInstallationIDForOwner(ctx context.Context, owner string) (types.GitHubAppInstallID, error) {
	if mock.GetInstallationIDForOwnerFunc == nil {
		panic("GitHubAppMock.GetInstallationIDForOwnerFunc: method is nil but GitHubApp.GetInstallationIDForOwner was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Owner string
	}{
		Ctx:   ctx,
		Owner: owner,
	}
	mock.lockGetInstallationIDForOwner.Lock()
	mock.calls.GetInstallationIDForOwner = append(mock.calls.GetInstallationIDForOwner, callInfo)
	mock.lockGetInstallationIDForOwner.Unlock()
	return mock.GetInstallationIDForOwnerFunc(ctx, owner)
}

// GetInstallationIDForOwnerCalls gets all the calls that were made to GetInstallationIDForOwner.
// Check the length with:
//
//	len(mockedGitHubApp.GetInstallationIDForOwnerCalls())
func (mock *GitHubAppMock) GetInstallationIDForOwnerCalls() []struct {
	Ctx   context.Context
	Owner string
} {
	var calls []struct {
		Ctx   context.Context
		Owner string
	}
	mock.lockGetInstallationIDForOwner.RLock()
	calls = mock.calls.GetInstallationIDForOwner
	mock.lockGetInstallationIDForOwner.RUnlock()
	return calls
}

// HTTPClient calls HTTPClientFunc.
func (mock *GitHubAppMock) HTTPClient(installID types.GitHubAppInstallID) (*http.Client, error) {
	if mock.HTTPClientFunc == nil {
		panic("GitHubAppMock.HTTPClientFunc: method is nil but GitHubApp.HTTPClient was just called")
	}
	callInfo := struct {
		InstallID types.GitHubAppInstallID
	}{
		InstallID: installID,
	}
	mock.lockHTTPClient.Lock()
	mock.calls.HTTPClient = append(mock.calls.HTTPClient, callInfo)
	mock.lockHTTPClient.Unlock()
	return mock.HTTPClientFunc(installID)
}

// HTTPClientCalls gets all the calls that were made to HTTPClient.
// Check the length with:
//
//	len(mockedGitHubApp.HTTPClientCalls())
func (mock *GitHubAppMock) HTTPClientCalls() []struct {
	InstallID types.GitHubAppInstallID
} {
	var calls []struct {
		InstallID types.GitHubAppInstallID
	}
	mock.lockHTTPClient.RLock()
	calls = mock.calls.HTTPClient
	mock.lockHTTPClient.RUnlock()
	return calls
}

// ListInstallationRepos calls ListInstallationReposFunc.
func (mock *GitHubAppMock) ListInstallationRepos(ctx context.Context, installID types.GitHubAppInstallID) ([]*model.GitHubAPIRepository, error) {
	if mock.ListInstallationReposFunc == nil {
		panic("GitHubAppMock.ListInstallationReposFunc: method is nil but GitHubApp.ListInstallationRepos was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		InstallID types.GitHubAppInstallID
	}{
		Ctx:       ctx,
		InstallID: installID,
	}
	mock.lockListInstallationRepos.Lock()
	mock.calls.ListInstallationRepos = append(mock.calls.ListInstallationRepos, callInfo)
	mock.lockListInstallationRepos.Unlock()
	return mock.ListInstallationReposFunc(ctx, installID)
}

// ListInstallationReposCalls gets all the calls that were made to ListInstallationRepos.
// Check the length with:
//
//	len(mockedGitHubApp.ListInstallationReposCalls())
func (mock *GitHubAppMock) ListInstallationReposCalls() []struct {
	Ctx       context.Context
	InstallID types.GitHubAppInstallID
} {
	var calls []struct {
		Ctx       context.Context
		InstallID types.GitHubAppInstallID
	}
	mock.lockListInstallationRepos.RLock()
	calls = mock.calls.ListInstallationRepos
	mock.lockListInstallationRepos.RUnlock()
	return calls
}
